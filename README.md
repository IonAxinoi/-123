1. Придумайте класс, который описывает любую сущность из предметной области библиотеки: книга, шкаф, комната и т.п.

       Класс Книга

2. Опишите свойства классов из п.1 (состояние).

Свойства класса Книга:
  
     название (string) — название книги.
     автор (string) — имя автора книги.
     ISBN (string) — уникальный идентификатор книги.
     количествоСтраниц (int) — число страниц в книге.
     жанр (string) — жанр книги.
     датаИздания (DateTime) — дата публикации книги.
     наличие (bool) — доступность книги для выдачи.

3. Опишите поведение классов из п.1 (методы).

Методы класса Книга:
     
     получитьИнформацию() — выводит полную информацию о книге.
     выдать() — изменяет статус наличие на false, указывая, что книга выдана.
     вернуть() — изменяет статус наличие на true, указывая, что книга возвращена.
     обновитьИнформацию($новыеДанные) — обновляет свойства книги на основе переданных данных.

4. Придумайте наследников классов из п.1. Чем они будут отличаться?

Наследники класса Книга:
  
  Класс ЭлектроннаяКнига
        
    Дополнительные свойства:
             
               форматФайла (string) — формат электронного файла (e.g., PDF, EPUB).
              ссылкаНаСкачивание (string) — URL для скачивания книги.
Отличия:

     Метод выдать() возвращает ссылку на скачивание вместо изменения статуса наличия.

Класс БумажнаяКнига

       Дополнительные свойства:
             местоХранения (string) — адрес библиотеки или шкафа, где хранится книга.
Отличия:

     Метод выдать() предоставляет информацию о местоположении книги для получения.


Структура классов : 


    abstract class Книга {
    protected $название;
    protected $автор;
    protected $ISBN;
    protected $количествоСтраниц;
    protected $жанр;
    protected $датаИздания;
    protected $количествоПрочтений = 0;
  
     public function __construct($название, $автор, $ISBN, $количествоСтраниц, $жанр, $датаИздания) {
        $this->название = $название;
        $this->автор = $автор;
        $this->ISBN = $ISBN;
        $this->количествоСтраниц = $количествоСтраниц;
        $this->жанр = $жанр;
        $this->датаИздания = $датаИздания;
    }

    abstract public function получитьНаРуки();

    public function увеличитьСтатистику() {
        $this->количествоПрочтений++;
    }

    // Геттеры и сеттеры для свойств
     }

    class ЭлектроннаяКнига extends Книга {
    private $ссылкаНаСкачивание;

    public function __construct($название, $автор, $ISBN, $количествоСтраниц, $жанр, $датаИздания, $ссылкаНаСкачивание) {
        parent::__construct($название, $автор, $ISBN, $количествоСтраниц, $жанр, $датаИздания);
        $this->ссылкаНаСкачивание = $ссылкаНаСкачивание;
    }

    public function получитьНаРуки() {
        $this->увеличитьСтатистику();
        return $this->ссылкаНаСкачивание;
    }
    }

    class БумажнаяКнига extends Книга {
    private $местоХранения;

    public function __construct($название, $автор, $ISBN, $количествоСтраниц, $жанр, $датаИздания, $местоХранения) {
        parent::__construct($название, $автор, $ISBN, $количествоСтраниц, $жанр, $датаИздания);
        $this->местоХранения = $местоХранения;
    }

    public function получитьНаРуки() {
        $this->увеличитьСтатистику();
        return $this->местоХранения;
    }
    }



Что вынести в абстрактный класс:
  
    Свойства, общие для всех типов книг (название, автор, ISBN, и т.д.).
    Метод увеличитьСтатистику().
    Абстрактный метод получитьНаРуки().

Что наследовать:
    
    Реализация метода получитьНаРуки() в каждом подклассе (ЭлектроннаяКнига и БумажнаяКнига), так как поведение различается.


================================================================================================

6.Дан код : 

    class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
    }
    $a1 = new A();
    $a2 = new A();
    $a1->foo();
    $a2->foo();
    $a1->foo();
    $a2->foo();

Вывод кода : 
      
     1
     2
     3
     4
Пояснение: В PHP ключевое слово static внутри метода означает, что переменная $x сохраняет своё значение между вызовами метода и разделяется между всеми экземплярами класса. Таким образом:

     $a1->foo(); — $x увеличивается с 0 до 1 и выводится 1.
     $a2->foo(); — $x увеличивается с 1 до 2 и выводится 2.
     $a1->foo(); — $x увеличивается с 2 до 3 и выводится 3.
     $a2->foo(); — $x увеличивается с 3 до 4 и выводится 4.

Изменили код :

    class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
    }
    class B extends A {
    }
    $a1 = new A();
    $b1 = new B();
    $a1->foo();
    $b1->foo();
    $a1->foo();
    $b1->foo();
Вывод кода :

    1
    1
    2
    2

Пояснение: В PHP static переменные внутри методов зависят от класса, в котором метод был объявен. Хотя класс B наследует метод foo() от класса A, каждая версия метода для A и B имеет свою собственную статическую переменную $x.

Таким образом:

    $a1->foo(); — $x для класса A увеличивается с 0 до 1 и выводится 1.
    $b1->foo(); — $x для класса B (наследника A) увеличивается с 0 до 1 и выводится 1.
    $a1->foo(); — $x для класса A увеличивается с 1 до 2 и выводится 2.
    $b1->foo(); — $x для класса B увеличивается с 1 до 2 и выводится 2.

